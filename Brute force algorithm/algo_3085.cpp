/*============================================
3085. 사탕게임
[문제]
상근이는 어렸을 적에 "봄보니 (Bomboni)" 게임을 즐겨했다.

가장 처음에 N×N크기에 사탕을 채워 놓는다. 사탕의 색은 모두 같지 않을 수도 있다. 상근이는 사탕의 색이 다른 인접한 두 칸을 고른다. 그 다음 고른 칸에 들어있는 사탕을 서로 교환한다. 이제, 모두 같은 색으로 이루어져 있는 가장 긴 연속 부분(행 또는 열)을 고른 다음 그 사탕을 모두 먹는다.

사탕이 채워진 상태가 주어졌을 때, 상근이가 먹을 수 있는 사탕의 최대 개수를 구하는 프로그램을 작성하시오.

[입력]
첫째 줄에 보드의 크기 N이 주어진다. (3 ≤ N ≤ 50)

다음 N개 줄에는 보드에 채워져 있는 사탕의 색상이 주어진다. 빨간색은 C, 파란색은 P, 초록색은 Z, 노란색은 Y로 주어진다.

사탕의 색이 다른 인접한 두 칸이 존재하는 입력만 주어진다.

[출력]
첫째 줄에 상근이가 먹을 수 있는 사탕의 최대 개수를 출력한다.

[개념]
보드에 있는 사탕을 선택하여 오른쪽 사탕과 바꾼 후 보드에서 가장 긴 사탕줄을 확인한다.
가장 긴 사탕줄의 길이를 저장하고 다시 오른쪽 사탕과 바꿔 원위치에 둔다.
이번엔 밑쪽 사탕과 바꾼 후 위와 동일하게 수행한다.
위 과정을 모든 사탕을 선택하여 진행하되, 오른쪽 혹은 밑쪽 사탕이 없는 경우엔 수행하지 않는다.
가장 긴 사탕줄의 길이를 출력한다.


============================================*/
#include <iostream>
int mx,n; 							//mx : 최대값 저장 변수, n : 사탕판 길이
char candy[52][52]; 						//사탕 저장 배열
void _swap(char &a, char &b){					//char형 swap 함수
	char temp;
	temp = a;
	a = b;
	b = temp;
}
void _count(){						//현재 사탕판에서 가장 긴 사탕줄을 찾아주는 함수
	int cnt=0;
	char flag;
	for(int i=0;i<n;i++){					//세로행 스캔
		for(int j=0;j<=n;j++){
			if(flag!=candy[j][i]){			//지금 세고 있는 사탕과 다른 사탕이라면
                			if(cnt>mx) mx = cnt;		//지금까지 센 갯수가 최대 갯수보다 많으면 저장
                			cnt=0;			//센 갯수 초기화
                			flag = candy[j][i];		//세고 있는 사탕을 지금 사탕으로 변경
			}
			cnt++;				//센 갯수 + 1
		}
	}
	for(int i=0;i<n;i++){					//가로열 스캔
		for(int j=0;j<=n;j++){
			if(flag!=candy[i][j]){
                			if(cnt>mx) mx = cnt;
                			cnt=0;
                			flag = candy[i][j];
			}
			cnt++;
		}
	}
}
int main(){
	std::cin >> n;
	for(int i=0;i<n;i++) std::cin >> candy[i];
	for(int i=0;i<n;i++){					//오른쪽 사탕과 바꿀 때
		for(int j=0;j<n-1;j++){
			if(candy[i][j]==candy[i][j+1]) continue;	//현재 사탕과 오른쪽 사탕이 같으면 다음 사탕으로 넘어간다.
			_swap(candy[i][j],candy[i][j+1]);		//오른쪽 사탕과 교환
			_count();				//가장 긴 사탕줄 확인
			_swap(candy[i][j],candy[i][j+1]);		//원위치
		}
	}
	for(int i=0;i<n;i++){					//밑쪽 사탕과 바꿀 때
		for(int j=0;j<n-1;j++){
			if(candy[j][i]==candy[j+1][i]) continue;
			_swap(candy[j][i],candy[j+1][i]);		//밑쪽 사탕과 교환
			_count();				//가장 긴 사탕줄 확인
			_swap(candy[j][i],candy[j+1][i]);		//원위치
		}
	}
	std::cout << mx;
}