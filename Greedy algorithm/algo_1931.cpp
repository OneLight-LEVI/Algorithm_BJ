/*============================================
1931. 회의실 배정
[문제]
한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.

[입력]
첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 시작 시간과 끝나는 시간은 231-1보다 작거나 같은 자연수 또는 0이다.

[출력]
첫째 줄에 최대 사용할 수 있는 회의의 최대 개수를 출력한다.

[개념]
회의의 최대 개수를 구하기 위해선 가능한 한 현재 시간에 가까운 종료시간을 가진 회의를 포함해야한다.
그러므로 종료시간의 오름차순으로 데이터를 정렬하고 현재 시간보다 큰 시작시간을 가진 회의가 있다면 개수에 포함시키고 그 회의의 종료시간을 현재시간으로 한다.
이렇게 얻은 개수가 회의의 최대 개수가 될 것이다.

1차 시도 - 실패
[반례]
5
1 3
5 5
3 5
2 6
7 8

해결법 : 종료시간이 같을 시 시작시간의 오름차순으로 정렬조건 추가

2차 시도 - 성공!
메모리 2800KB, 시간 88ms, 코드 길이 426B
============================================*/

#include <iostream>
#include <algorithm>
using namespace std;
struct sch{						//회의시간 구조체
	int start; 					//시작 시간
	int end; 					//종료 시간
};
sch t[100001]; 					//회의시간 데이터
int comp(sch a, sch b){				//정렬 조건함수, 종료시간의 오름차순, 같다면 시작시간의 오름차순
	if(a.end==b.end) return a.start < b.start;		//종료시간이 같다면 시작시간의 오름차순으로
	return a.end < b.end;			//종료시간의 오름차순
}
int main(){
	int n, now = 0,cnt = 0;			//회의의 수, 현재 시간, 회의의 개수
	cin >> n;					//회의의 수 입력
	for(int i=0;i<n;i++) cin >> t[i].start >> t[i].end;	//회의시간 데이터 입력
	sort(t,t+n,comp);				//회의시간 정렬
	for(int i=0;i<n;i++){
		if(now <= t[i].start){			//현재시간이 i번 회의의 시작시간보다 작거나 같다면
			now = t[i].end;		//현재시간은 i번 회의의 종료시간이 된다.
			cnt++;			//회의를 한 것으로 회의의 개수에 1 더한다.
		}
	}
	cout << cnt;				//위 알고리즘으로 얻은 회의의 개수는 최대개수이다.
}